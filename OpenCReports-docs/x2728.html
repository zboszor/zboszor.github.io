<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Low level C API</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="OpenCReports 0.5 Manual"
HREF="book1.html"><LINK
REL="UP"
TITLE="C language API reference"
HREF="c2687.html"><LINK
REL="PREVIOUS"
TITLE="High level C API"
HREF="x2693.html"><LINK
REL="NEXT"
TITLE="GNU Free Documentation License"
HREF="c3537.html"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>OpenCReports 0.5 Manual</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x2693.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>C language API reference</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c3537.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="lowlevelapi"
>Low level C API</A
></H1
><P
>&#13;			The <A
HREF="x2693.html"
>High level C API</A
> is also part of the
			low level API. The functions described below allow
			creating a report using program code, or simply
			fine tuning the report behavior by mostly using the
			<A
HREF="x2693.html"
>High level C API</A
>.
		</P
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="numerictuning"
>Numeric behavior related functions</A
></H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2735"
><TT
CLASS="literal"
>Set numeric precision</TT
></A
></H3
><P
>&#13;					The default is 256 bits of floating point precision.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void ocrpt_set_numeric_precision_bits(opencreport *o,
                                      mpfr_prec_t prec);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2740"
>Set rounding mode</A
></H3
><P
>&#13;					OpenCReports uses GNU MPFR under the hood and does't
					hide this fact. The MPFR rounding mode constants are
					used as is to set the rounding behaviour.
					The default is <TT
CLASS="literal"
>MPFR_RNDN</TT
>, round
					to nearest.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void ocrpt_set_rounding_mode(opencreport *o,
                             mpfr_rnd_t rndmode);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN2745"
>Locale related functions</A
></H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2747"
>Set report locale</A
></H3
><P
>&#13;					Setting the locale for the report does not affect
					the main program or other threads. Locale setting
					includes the language, the country. The UTF-8 suffix
					is necessary. E.g.: <TT
CLASS="literal"
>en_GB.UTF-8</TT
> or
					<TT
CLASS="literal"
>de_DE.UTF-8</TT
>
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void ocrpt_set_locale(opencreport *o,
                      const char *locale);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2753"
>Print monetary data in the report locale</A
></H3
><P
>&#13;					A customized monetary printing function was implemented
					for the purposes of the report which MPFR doesn't
					provide. It is used in OpenCReports both internally
					and by unit tests.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ssize_t ocrpt_mpfr_strfmon(opencreport *o,
                           char *s, size_t maxsize,
                           const char *format, ...);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN2757"
>Data source and query related functions</A
></H2
><P
>&#13;				The following <TT
CLASS="literal"
>enum</TT
> and
				<TT
CLASS="literal"
>struct</TT
> types are used by
				OpenCReports for datasources and queries.
				<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>enum ocrpt_result_type {
    OCRPT_RESULT_ERROR,
    OCRPT_RESULT_STRING,
    OCRPT_RESULT_NUMBER,
    OCRPT_RESULT_DATETIME
};

struct ocrpt_datasource;
typedef struct ocrpt_datasource ocrpt_datasource;

struct ocrpt_query;
typedef struct ocrpt_query ocrpt_query;

struct ocrpt_query_result;
typedef struct ocrpt_query_result ocrpt_query_result;

struct ocrpt_input {
    void (*describe)(ocrpt_query *,
                     ocrpt_query_result **,
                     int32_t *);
    void (*rewind)(ocrpt_query *);
    bool (*next)(ocrpt_query *);
    bool (*populate_result)(ocrpt_query *);
    bool (*isdone)(ocrpt_query *);
    void (*free)(ocrpt_query *);
    bool (*set_encoding)(ocrpt_datasource *,
                         const char *);
    void (*close)(const ocrpt_datasource *);
};
typedef struct ocrpt_input ocrpt_input;</PRE
></TD
></TR
></TABLE
>
			</P
><P
>&#13;				Data sources in this context are "mini drivers".
				Data source handling is implemented via
				<TT
CLASS="literal"
>ocrpt_input</TT
> functions.
			</P
><P
>&#13;				Queries are data providers over data sources. They are
				the actual sources of data using a specific data source.
				Multiple queries may use the same data source.
			</P
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2766"
>Add an array datasource</A
></H3
><P
>&#13;					Add an array datasource to the report handler.
					It's optional, as an array datasource called
					"array" is automatically added to an opencreport
					structure.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_datasource *
ocrpt_datasource_add_array(opencreport *o,
                           const char *source_name);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2770"
>Add an array query</A
></H3
><P
>&#13;					Add an "array query" to the report handler.
					This adds the array pointer and parameters, so
					the array datasource input driver can use it.
					The provided <TT
CLASS="literal"
>array</TT
> array pointer
					contains <TT
CLASS="literal"
>(rows + 1) * cols</TT
> number of
					<TT
CLASS="literal"
>char *</TT
> pointers, with the first row
					being the column (field) names. The
					<TT
CLASS="literal"
>types</TT
> array contains
					<TT
CLASS="literal"
>cols</TT
> number of
					<TT
CLASS="literal"
>enum ocrpt_result_type</TT
> elements to
					indicate the column data type.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_query *
ocrpt_query_add_array(opencreport *o,
                      ocrpt_datasource *source,
                      const char *name,
                      const char **array,
                      int32_t rows, int32_t cols,
                      const enum ocrpt_result_type *types);</PRE
></TD
></TR
></TABLE
>
				</P
><P
>&#13;					If the <TT
CLASS="literal"
>types</TT
> pointer is
					<TT
CLASS="literal"
>NULL</TT
>, the column values are treated
					as strings. This is how RLIB operated.
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2783"
>Add a CSV datasource</A
></H3
><P
>&#13;					Add a CSV datasource to the report handler.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_datasource *
ocrpt_datasource_add_csv(opencreport *o,
                         const char *source_name);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2787"
>Add a CSV query</A
></H3
><P
>&#13;					Add a "CSV query" to the report handler.
					This specifies the file name, so
					the CSV datasource input driver can load it.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_query *
ocrpt_query_add_csv(opencreport *o,
                    ocrpt_datasource *source,
                    const char *name,
                    const char *filename,
                    const enum ocrpt_result_type *types);</PRE
></TD
></TR
></TABLE
>
				</P
><P
>&#13;					The <TT
CLASS="literal"
>types</TT
> array pointer is optional.
					If it is <TT
CLASS="literal"
>NULL</TT
>, the column values are
					treated as strings. This is how RLIB operated.
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2794"
>Add a JSON datasource</A
></H3
><P
>&#13;					Add a JSON datasource to the report handler.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_datasource *
ocrpt_datasource_add_json(opencreport *o,
                          const char *source_name);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2798"
>Add a JSON query</A
></H3
><P
>&#13;					Add a "JSON query" to the report handler.
					This specifies the file name, so
					the JSON datasource input driver can load it.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_query *
ocrpt_query_add_json(opencreport *o,
                     ocrpt_datasource *source,
                     const char *name,
                     const char *filename,
                     const enum ocrpt_result_type *types);</PRE
></TD
></TR
></TABLE
>
				</P
><P
>&#13;					The JSON file format defined in <A
HREF="x277.html#jsonds"
>JSON file datasource</A
>
					contains the way to describe the column data types,
					which is optional in a JSON file.
					The <TT
CLASS="literal"
>types</TT
> array pointer may
					optionally supplement (or override) the column types.
					It is only meaningful if the JSON file itself doesn't
					contain the type description for the columns. If it is
					<TT
CLASS="literal"
>NULL</TT
> (and the JSON file doesn't
					contain type specifiers), the column values are
					treated as strings. RLIB didn't have JSON input.
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2806"
>Add an XML datasource</A
></H3
><P
>&#13;					Add an XML datasource to the report handler.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_datasource *
ocrpt_datasource_add_xml(opencreport *o,
                         const char *source_name);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2810"
>Add an XML query</A
></H3
><P
>&#13;					Add an "XML query" to the report handler.
					This specifies the file name, so
					the XML datasource input driver can load it.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_query *
ocrpt_query_add_xml(opencreport *o,
                    ocrpt_datasource *source,
                    const char *name,
                    const char *filename,
                    const enum ocrpt_result_type *types);</PRE
></TD
></TR
></TABLE
>
				</P
><P
>&#13;					The XML file format defined in <A
HREF="x277.html#xmlds"
>XML file datasource</A
>
					contains the way to describe the column data types,
					which is optional in an XML file.
					The <TT
CLASS="literal"
>types</TT
> array pointer may
					optionally supplement (or override) the column types.
					It is only meaningful if the XML file itself doesn't
					contain the type description for the columns. If it is
					<TT
CLASS="literal"
>NULL</TT
> (and the XML file doesn't
					contain type specifiers), the column values are
					treated as strings. This is how RLIB operated.
					The OpenCReports XML input file format is RLIB
					compatible without the type specification part.
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2818"
>Add a PostgreSQL datasource</A
></H3
><P
>&#13;					Add a PostgreSQL datasource to the report handler.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_datasource *
ocrpt_datasource_add_postgresql(opencreport *o,
                                const char *source_name,
                                const char *host,
                                const char *port,
                                const char *dbname,
                                const char *user,
                                const char *password);

ocrpt_datasource *
ocrpt_datasource_add_postgresql2(opencreport *o,
                                 const char *source_name,
                                 const char *conninfo);</PRE
></TD
></TR
></TABLE
>
				</P
><P
>&#13;					For the parameters, see <A
HREF="x277.html#postgresqlds"
>PostgreSQL database connection</A
>.
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2824"
>Add a PostgreSQL query</A
></H3
><P
>&#13;					Add a SQL query using the PostgreSQL datasource
					to the report handler.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_query *
ocrpt_query_add_postgresql(opencreport *o,
                           ocrpt_datasource *source,
                           const char *name,
                           const char *querystr);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2828"
>Add a MariaDB datasource</A
></H3
><P
>&#13;					Add a MariaDB datasource to the report handler.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_datasource *
ocrpt_datasource_add_mariadb(opencreport *o,
                             const char *source_name,
                             const char *host,
                             const char *port,
                             const char *dbname,
                             const char *user,
                             const char *password,
                             const char *unix_socket);

ocrpt_datasource *
ocrpt_datasource_add_mariadb2(opencreport *o,
                              const char *source_name,
                              const char *optionfile,
                              const char *group);</PRE
></TD
></TR
></TABLE
>
				</P
><P
>&#13;					For the parameters, see <A
HREF="x277.html#mariadbds"
>MariaDB database connection</A
>.
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2834"
>Add a MariaDB query</A
></H3
><P
>&#13;					Add an SQL query using the MariaDB datasource
					to the report handler.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_query *
ocrpt_query_add_mariadb(opencreport *o,
                        ocrpt_datasource *source,
                        const char *name,
                        const char *querystr);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2838"
>Add an ODBC datasource</A
></H3
><P
>&#13;					Add an ODBC datasource to the report handler.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_datasource *
ocrpt_datasource_add_odbc(opencreport *o,
                          const char *source_name,
                          const char *dbname,
                          const char *user, const char *password);

ocrpt_datasource *
ocrpt_datasource_add_odbc2(opencreport *o,
                           const char *source_name,
                           const char *conninfo);</PRE
></TD
></TR
></TABLE
>
				</P
><P
>&#13;					For the parameters, see <A
HREF="x277.html#odbcds"
>ODBC database connection</A
>.
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2844"
>Add an ODBC query</A
></H3
><P
>&#13;					Add an SQL query using the ODBC datasource
					to the report handler.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_query *
ocrpt_query_add_odbc(opencreport *o,
                     ocrpt_datasource *source,
                     const char *name,
                     const char *querystr);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2848"
>Find a datasource</A
></H3
><P
>&#13;					Find the data source using its name.
					It returns NULL if the named data source
					is not found.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_datasource *
ocrpt_datasource_get(opencreport *o,
                     const char *source_name);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2852"
><TT
CLASS="literal"
>Add a custom datasource</TT
></A
></H3
><P
>&#13;					Add a custom data source to the report handler.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_datasource *
ocrpt_add_datasource(opencreport *o,
                     const char *source_name,
                     const ocrpt_input *input);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2857"
><TT
CLASS="literal"
>Set the encoding of a datasource</TT
></A
></H3
><P
>&#13;					Set the encoding of a datasource in case
					if it's not already UTF-8, so data provided by
					it is automatically converted.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_datasource_set_encoding(opencreport *o,
                              ocrpt_datasource *source,
                              const char *encoding);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2862"
><TT
CLASS="literal"
>Free a datasource</TT
></A
></H3
><P
>&#13;					Free a datasource from the opencreport structure
					it was added to. It's not needed to be called,
					all datasources are automatically free with
					<TT
CLASS="literal"
>ocrpt_free()</TT
>
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_datasource_free(opencreport *o,
                      ocrpt_datasource *source);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2868"
><TT
CLASS="literal"
>Find a query</TT
></A
></H3
><P
>&#13;					Find a query using its name.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_query *
ocrpt_query_get(opencreport *o,
                const char *name);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2873"
><TT
CLASS="literal"
>Get the current data row from a query</TT
></A
></H3
><P
>&#13;					Create (first call) or get the <TT
CLASS="literal"
>ocrpt_query_result</TT
>
					array from a query. Output parameter <TT
CLASS="literal"
>cols</TT
>
					returns the number of columns in the result array. It must
					be re-run after ocrpt_navigate_next() since the previously
					returned pointer becomes invalid.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_query_result *
ocrpt_query_get_result(ocrpt_query *q,
                       int32_t *cols);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2880"
><TT
CLASS="literal"
>Get column name</TT
></A
></H3
><P
>&#13;					Using the <TT
CLASS="literal"
>ocrpt_query_result *</TT
> result
					from <TT
CLASS="literal"
>ocrpt_query_get_result()</TT
>,
					the column names can be discovered from a query.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>const char *
ocrpt_query_result_column_name(ocrpt_query_result *qr,
                               int32_t col);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2887"
><TT
CLASS="literal"
>Get column data</TT
></A
></H3
><P
>&#13;					Using the <TT
CLASS="literal"
>ocrpt_query_result *</TT
>
					result from
					<TT
CLASS="literal"
>ocrpt_query_get_result()</TT
>, get a
					pointer to the column data in its internal (hidden)
					representation.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_result *
ocrpt_query_result_column_result(ocrpt_query_result *qr,
                                 int32_t col);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2894"
><TT
CLASS="literal"
>Add a follower query</TT
></A
></H3
><P
>&#13;					Add a <TT
CLASS="literal"
>follower</TT
> query to the
					<TT
CLASS="literal"
>leader</TT
> query. The leader is the primary
					query and the follower will run in parallel with it until
					the leader runs out of rows. In case the leader has more
					rows than the follower, then for rows in the leader where
					there are no follower rows, the follower fields are set to NULL.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>bool
ocrpt_add_query_follower(opencreport *o,
                         ocrpt_query *leader,
                         ocrpt_query *follower);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2901"
><TT
CLASS="literal"
>Add an N:1 follower query</TT
></A
></H3
><P
>&#13;					Add an N:1 <TT
CLASS="literal"
>follower</TT
> query to the
					<TT
CLASS="literal"
>leader</TT
> query. The leader is the primary
					query and rows from the follower will be matched using the
					<TT
CLASS="literal"
>match</TT
> expression. If there are multiple
					rows in the follower matching the leader row, then the leader
					row will be listed that many times. For rows in the leader
					where there are no matching rows in the follower, the follower
					fields are set to NULL. It is similar to <TT
CLASS="literal"
>LEFT OUTER
					JOIN</TT
> in SQL databases. For creating an
					<TT
CLASS="literal"
>ocrpt_expr</TT
> expression pointer, see the
					next section.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>bool
ocrpt_add_query_follower_n_to_1(opencreport *o,
                                ocrpt_query *leader,
                                ocrpt_query *follower,
                                ocrpt_expr *match);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2911"
><TT
CLASS="literal"
>Free a query</TT
></A
></H3
><P
>&#13;					Free a query and remove it from the report handler.
					It's optional. <TT
CLASS="literal"
>ocrpt_free()</TT
> frees
					the queries added to the <TT
CLASS="literal"
>opencreport</TT
>
					structure.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_query_free(opencreport *o,
                 ocrpt_query *q);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2918"
><TT
CLASS="literal"
>Start the main query</TT
></A
></H3
><P
>&#13;					Start query (or query set) navigation.
					<TT
CLASS="literal"
>q</TT
> should be the primary query
					of the report.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_query_navigate_start(opencreport *o,
                           ocrpt_query *q);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2924"
><TT
CLASS="literal"
>Navigate to the next query row</TT
></A
></H3
><P
>&#13;					Navigate the query (or query set) to the next row. Returns
					<TT
CLASS="literal"
>false</TT
> if there was no more rows.
					in which case the <TT
CLASS="literal"
>ocrpt_query_result</TT
>
					arrays for all queries in the query set (returned by
					previous <TT
CLASS="literal"
>ocrpt_query_get_result()</TT
>
					calls contain invalid data.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>bool
ocrpt_query_navigate_next(opencreport *o,
                          ocrpt_query *q);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2932"
><TT
CLASS="literal"
>API specific array discovery function</TT
></A
></H3
><P
>&#13;					For array data sources and queries, OpenCReports
					needs a way to to find the data array and the
					supplementary type identifier array.
					These are language specific. The below ones
					are the C specific ones. The override function
					is also provided to set a new discovery function.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>typedef void
(*ocrpt_query_discover_func)(const char *,
                             void **,
                             const char *,
                             void **);

void
ocrpt_query_set_discover_func(ocrpt_query_discover_func func);

extern ocrpt_query_discover_func ocrpt_query_discover_array;

void
ocrpt_query_discover_array_c(const char *arrayname,
                             void **array,
                             const char *typesname,
                             void **types);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="exprfunc"
>Expression related functions</A
></H2
><P
>&#13;				Expressions in OpenCReports is explained in the
				<A
HREF="c1689.html"
>Expressions</A
> chapter.
			</P
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2941"
>Parse an expression string</A
></H3
><P
>&#13;					This function parses an expression string and
					creates an expression tree. It returns a pointer
					to the <TT
CLASS="literal"
>ocrpt_expr</TT
> structure.
				</P
><P
>&#13;					If an error occurs, it returns NULL and optionally
					returns the error message in <TT
CLASS="literal"
>err</TT
>
					pointer if it's not <TT
CLASS="literal"
>NULL</TT
>.
				</P
><P
>&#13;					The <TT
CLASS="literal"
>ocrpt_report</TT
> pointer may be
					valid or NULL. If valid, the expression is bound
					to this <TT
CLASS="literal"
>ocrpt_report</TT
>, i.e.
					it will be freed automatically with
					<TT
CLASS="literal"
>ocrpt_free()</TT
>.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_expr *
ocrpt_expr_parse(opencreport *o,
                 ocrpt_report *r,
                 const char *str,
                 char **err);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2953"
>Free an expression parse tree</A
></H3
><P
>&#13;					Free an expression parse tree. If it was bound
					to the passed-in <TT
CLASS="literal"
>ocrpt_report</TT
>,
					this association is also deleted. Alternatively,
					the expression doesn't need to be free if it was
					bound to a report when it was parsed, as it will be
					automatically freed when freeing either the report,
					or the global <TT
CLASS="literal"
>opencreport</TT
> structure.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_expr_free(opencreport *o,
                ocrpt_report *r,
                ocrpt_expr *e);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2959"
>Resolve expression references</A
></H3
><P
>&#13;					This function resolves variable (identifier)
					references in the expression. This is needed
					to bind query columns to expressions that
					use them.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_expr_resolve(opencreport *o,
                   ocrpt_report *r,
                   ocrpt_expr *e);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2963"
>Optimize an expression</A
></H3
><P
>&#13;					This function optimizes an expression so
					it may needs fewer computation steps during
					report execution.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_expr_optimize(opencreport *o,
                    ocrpt_report *r,
                    ocrpt_expr *e);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2967"
>Evaluate an expression</A
></H3
><P
>&#13;					This function evaluates the expression.
					It returns the expression's
					<TT
CLASS="literal"
>ocrpt_result</TT
> result structure.
					The result must not be freed with
					<TT
CLASS="literal"
>ocrpt_result_free()</TT
>.
					It will be done by <TT
CLASS="literal"
>ocrpt_expr_free()</TT
>
				</P
><P
>&#13;					For expressions with query column references,
					this function must be called after
					<TT
CLASS="literal"
>ocrpt_query_navigate_next</TT
>
					otherwise the result is not valid.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_result *
ocrpt_expr_eval(opencreport *o,
                ocrpt_report *r,
                ocrpt_expr *e);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2976"
>Get expression result without evaluation</A
></H3
><P
>&#13;					This function returns the expression result
					if it was already evaluated.
					The result must not be freed with
					<TT
CLASS="literal"
>ocrpt_result_free()</TT
>.
					It will be done by <TT
CLASS="literal"
>ocrpt_expr_free()</TT
>.
					Used by unit tests.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_result *
ocrpt_expr_get_result(opencreport *o,
                      ocrpt_expr *e);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2982"
>Print an expression tree</A
></H3
><P
>&#13;					Print an expression tree in its processed form on the
					standard output. Used by unit tests.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_expr_print(opencreport *o,
                 ocrpt_expr *e);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2986"
>Print an expression tree with subexpressions and their results</A
></H3
><P
>&#13;					Print an expression tree with subexpressions
					and their results in its processed form on the
					standard output. Used by unit tests.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_expr_result_deep_print(opencreport *o,
                             ocrpt_expr *e);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2990"
>Count the number of expression nodes</A
></H3
><P
>&#13;					This function returns the number of expression nodes.
					Used by unit tests to validate optimizazion.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>int32_t
ocrpt_expr_nodes(ocrpt_expr *e);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2994"
>Initialize expression result type</A
></H3
><P
>&#13;					OpenCReports keeps track of the last three query
					rows and computes three result values for expressions
					for internal reasons. These functions initialize
					the type for either the current result or all results
					of the expression.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>enum ocrpt_result_type {
    OCRPT_RESULT_ERROR,
    OCRPT_RESULT_STRING,
    OCRPT_RESULT_NUMBER,
    OCRPT_RESULT_DATETIME
};

bool ocrpt_expr_init_result(opencreport *o,
                            ocrpt_expr *e,
                            enum ocrpt_result_type type);

void ocrpt_expr_init_results(opencreport *o,
                             ocrpt_expr *e,
                             enum ocrpt_result_type type);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN2998"
>Set an error string as expression result</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_result *
ocrpt_expr_make_error_result(opencreport *o,
                             ocrpt_expr *e,
                             const char *format, ...);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3002"
>Set start value flag for an iterative expression</A
></H3
><P
>&#13;					Set whether the iterative expression's first
					value is computed from its base expression
					or from its result expression.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_expr_set_iterative_start_value(ocrpt_expr *e,
                                     bool start_with_init);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3006"
>Get current value of an expression in base type</A
></H3
><P
>&#13;					Get the current value of an expression in a C base
					type. Used by parsing report description XML files
					and unit tests.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>const char *
ocrpt_expr_get_string_value(opencreport *o,
                            ocrpt_expr *e);

long
ocrpt_expr_get_long_value(opencreport *o,
                          ocrpt_expr *e);

double
ocrpt_expr_get_double_value(opencreport *o,
                            ocrpt_expr *e);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3010"
>Set current value of an expression in a base type</A
></H3
><P
>&#13;					Used by unit tests.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_expr_set_string_value(opencreport *o,
                            ocrpt_expr *e,
                            const char *s);

void
ocrpt_expr_set_long_value(opencreport *o,
                          ocrpt_expr *e,
                          long l);

void
ocrpt_expr_set_double_value(opencreport *o,
                            ocrpt_expr *e,
                            double d);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3014"
>Set nth value of an expression in a base type</A
></H3
><P
>&#13;					Expressions use <TT
CLASS="literal"
>OCRPT_EXPR_RESULTS</TT
>
					number of values. With these functions, any of them
					can be set. Used by unit tests.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_expr_set_nth_result_string_value(opencreport *o,
                                       ocrpt_expr *e,
                                       int which,
                                       const char *s);

void
ocrpt_expr_set_nth_result_long_value(opencreport *o,
                                     ocrpt_expr *e,
                                     int which,
                                     long l);

void
ocrpt_expr_set_nth_result_double_value(opencreport *o,
                                       ocrpt_expr *e,
                                       int which,
                                       double d);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3019"
>Compare current and previous values of and expression</A
></H3
><P
>&#13;					Compare current and previous values of and expression
					and return <TT
CLASS="literal"
>true</TT
> if they are equal.
					It's used to implement <A
HREF="c2383.html"
>Report breaks</A
>.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>bool
ocrpt_expr_cmp_results(opencreport *o,
                       ocrpt_expr *e);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3025"
>Set delayed flag of an expression</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_expr_set_delayed(opencreport *o,
                       ocrpt_expr *e,
                       bool delayed);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3029"
>Set field expression reference for an expression</A
></H3
><P
>&#13;					If <TT
CLASS="literal"
>e</TT
> contains <TT
CLASS="literal"
>r.value</TT
>,
					the expression <TT
CLASS="literal"
>rvalue</TT
> will be used to
					resolve this reference.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_expr_set_field_expr(opencreport *o,
                          ocrpt_expr *e,
                          ocrpt_expr *rvalue);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN3036"
>Column data or expression result related functions</A
></H2
><P
>&#13;				The internal type <TT
CLASS="literal"
>ocrpt_result</TT
> holds
				values either for query columns or expression results.
			</P
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3040"
>Create an expression result</A
></H3
><P
>&#13;					The returned pointer must be freed with
					<TT
CLASS="literal"
>ocrpt_result_free()</TT
>.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_result *
ocrpt_result_new(void);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3045"
>Get expression result type</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>enum ocrpt_result_type
ocrpt_result_get_type(ocrpt_result *result);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3049"
>Copy an expression result</A
></H3
><P
>&#13;					Some internal data is specific to the
					<TT
CLASS="literal"
>opencreport</TT
> structure.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_result_copy(opencreport *o,
                  ocrpt_result *dst,
                  ocrpt_result *src);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3054"
>Print an expression result</A
></H3
><P
>&#13;					Used by unit tests.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_result_print(ocrpt_result *r);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3058"
>Free an expression result</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_result_free(ocrpt_result *r);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3062"
>Detect whether a column result is NULL</A
></H3
><P
>&#13;					Using the <TT
CLASS="literal"
>ocrpt_result *</TT
>
					result from a query column or an expression,
					detect whether the column value is NULL.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>bool
ocrpt_result_isnull(ocrpt_result *result);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3067"
>Detect whether a column result is numeric</A
></H3
><P
>&#13;					Using the <TT
CLASS="literal"
>ocrpt_result *</TT
>
					result from a query column or an expression,
					detect whether the column value is numeric.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>bool
ocrpt_result_isnumber(ocrpt_result *result);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3072"
>Get the numeric value of a column result</A
></H3
><P
>&#13;					Using the <TT
CLASS="literal"
>ocrpt_result *</TT
>
					result from a query column or an expression,
					get the numeric column value. It returns  NULL
					if the column is:
					<P
></P
><UL
><LI
STYLE="list-style-type: disc"
><P
>&#13;								not a numeric result
							</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>&#13;								NULL
							</P
></LI
></UL
>
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>mpfr_ptr
ocrpt_result_get_number(ocrpt_result *result);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3082"
>Detect whether a column result is string</A
></H3
><P
>&#13;					Using the <TT
CLASS="literal"
>ocrpt_result *</TT
>
					result from a query column or an expression,
					detect whether the column value is string.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>bool
ocrpt_result_isstring(ocrpt_result *result);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3087"
>Get the string value of a column result</A
></H3
><P
>&#13;					Using the <TT
CLASS="literal"
>ocrpt_result *</TT
>
					result from a query column or an expression,
					get the string column value. It returns  NULL
					if the column is
					<P
></P
><UL
><LI
STYLE="list-style-type: disc"
><P
>&#13;								not a string result
							</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>&#13;								NULL
							</P
></LI
></UL
>
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_string *
ocrpt_result_get_string(ocrpt_result *result);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3097"
>Detect whether a column result is datetime</A
></H3
><P
>&#13;					Using the <TT
CLASS="literal"
>ocrpt_result *</TT
>
					result from a query column or an expression,
					detect whether the column value is datetime.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>bool
ocrpt_result_isdatetime(ocrpt_result *result);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3102"
>Get the datetime value of a column result</A
></H3
><P
>&#13;					Using the <TT
CLASS="literal"
>ocrpt_result *</TT
>
					result from a query column or an expression,
					get the datetime column value. It returns  NULL
					if the column is
					<P
></P
><UL
><LI
STYLE="list-style-type: disc"
><P
>&#13;								not a datetime result
							</P
></LI
><LI
STYLE="list-style-type: disc"
><P
>&#13;								NULL
							</P
></LI
></UL
>
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>const struct tm *
ocrpt_result_get_datetime(ocrpt_result *result);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3112"
>Detect whether a datetime column result is interval</A
></H3
><P
>&#13;					Using the <TT
CLASS="literal"
>ocrpt_result *</TT
>
					result from a query column or an expression,
					detect whether the datetime column value is interval.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>bool
ocrpt_result_datetime_is_interval(ocrpt_result *result);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3117"
>Detect whether a datetime column result has valid date</A
></H3
><P
>&#13;					Using the <TT
CLASS="literal"
>ocrpt_result *</TT
>
					result from a query column or an expression,
					detect whether the datetime column value has valid date.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>bool
ocrpt_result_datetime_is_date_valid(ocrpt_result *result);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3122"
>Detect whether a datetime column result has valid time</A
></H3
><P
>&#13;					Using the <TT
CLASS="literal"
>ocrpt_result *</TT
>
					result from a query column or an expression,
					detect whether the datetime column value has valid time.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>bool
ocrpt_result_datetime_is_time_valid(ocrpt_result *result);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN3127"
>Variable related functions</A
></H2
><P
>&#13;				Variables can be created for a report using
				the API.
			</P
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3130"
>Create a basic variable</A
></H3
><P
>&#13;					Using this function, any variable type except
					<TT
CLASS="literal"
>OCRPT_VARIABLE_CUSTOM</TT
>
					may be created. For a custom variable,
					see the next function.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>enum ocrpt_var_type {
    OCRPT_VARIABLE_EXPRESSION,
    OCRPT_VARIABLE_COUNT,
    OCRPT_VARIABLE_COUNTALL,
    OCRPT_VARIABLE_SUM,
    OCRPT_VARIABLE_AVERAGE,
    OCRPT_VARIABLE_AVERAGEALL,
    OCRPT_VARIABLE_LOWEST,
    OCRPT_VARIABLE_HIGHEST,
    OCRPT_VARIABLE_CUSTOM
};
typedef enum ocrpt_var_type ocrpt_var_type;

ocrpt_var *
ocrpt_variable_new(opencreport *o,
                   ocrpt_report *r,
                   ocrpt_var_type type,
                   const char *name,
                   const char *expr,
                   const char *reset_on_break_name);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3135"
>Create a custom variable</A
></H3
><P
>&#13;					Create a custom variable of the specified type
					with the specified subexpressions.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_var *
ocrpt_variable_new_full(opencreport *o,
                        ocrpt_report *r,
                        enum ocrpt_result_type type,
                        const char *name,
                        const char *baseexpr,
                        const char *intermedexpr,
                        const char *intermed2expr,
                        const char *resultexpr,
                        const char *reset_on_break_name);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3139"
>Get subexpressions of a variable</A
></H3
><P
>&#13;					Get subexpressions of a previously created
					basic or custom variable.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_expr *
ocrpt_variable_baseexpr(ocrpt_var *v);

ocrpt_expr *
ocrpt_variable_intermedexpr(ocrpt_var *v);

ocrpt_expr *
ocrpt_variable_intermed2expr(ocrpt_var *v);

ocrpt_expr *
ocrpt_variable_resultexpr(ocrpt_var *v);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3143"
>Set precalculate flag for a variable</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_variable_set_precalculate(ocrpt_var *var, 
                                bool value);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3147"
>Resolve a variable</A
></H3
><P
>&#13;					Resolve subexpressions of a variable
					so it can be evaluated correctly.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_variable_resolve(opencreport *o,
                       ocrpt_report *r,
                       ocrpt_var *v);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3151"
>Evaluate a variable</A
></H3
><P
>&#13;					After evaluation, the result is in the
					expression returned by
					<TT
CLASS="literal"
>ocrpt_variable_resultexpr()</TT
>.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_variable_evaluate(opencreport *o,
                        ocrpt_report *r, ocrpt_var *v);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN3156"
>Break related functions</A
></H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3158"
>Create a break</A
></H3
><P
>&#13;					Create a break. No need to free it,
					<TT
CLASS="literal"
>ocrpt_free()</TT
> does it.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_break *
ocrpt_break_new(opencreport *o,
                ocrpt_report *r,
                const char *name);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3163"
>Set attribute flags for a break</A
></H3
><P
>&#13;					Set boolean attribute flags for a break,
					either via explicit boolean value, or from
					an expression. The flags are not actually used,
					they are for RLIB compatibility.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>enum ocrpt_break_attr_type {
    OCRPT_BREAK_ATTR_NEWPAGE,
    OCRPT_BREAK_ATTR_HEADERNEWPAGE,
    OCRPT_BREAK_ATTR_SUPPRESSBLANK,
    OCRPT_BREAK_ATTRS_COUNT
};
typedef enum ocrpt_break_attr_type ocrpt_break_attr_type;

bool
ocrpt_break_set_attribute(opencreport *o,
                          ocrpt_report *r,
                          ocrpt_break *br,
                          const ocrpt_break_attr_type attr_type,
                          bool value);

bool
ocrpt_break_set_attribute_from_expr(opencreport *o,
                                    ocrpt_report *r,
                                    ocrpt_break *br,
                                    const ocrpt_break_attr_type attr_type,
                                    ocrpt_expr *expr);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3167"
>Get break using its name</A
></H3
><P
>&#13;					Get the pointer to the break using its name.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_break *
ocrpt_break_get(opencreport *o,
                ocrpt_report *r,
                const char *name);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3171"
>Get the name of a break</A
></H3
><P
>&#13;					Get the name of the break using its structure
					pointer.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>const char *
ocrpt_break_get_name(ocrpt_break *br);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3175"
>Add a watched expression to a break</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>bool
ocrpt_break_add_breakfield(opencreport *o,
                           ocrpt_report *r,
                           ocrpt_break *br,
                           ocrpt_expr *bf);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3179"
>Iterate over breaks of a report</A
></H3
><P
>&#13;					Iterate over breaks of a report. The first call
					needs the iterator list pointer to be set to NULL.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_break *
ocrpt_break_get_next(ocrpt_report *r,
                     ocrpt_list **list);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3183"
>Resolve and optimize break fields</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_break_resolve_fields(opencreport *o,
                           ocrpt_report *r,
                           ocrpt_break *br);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3187"
>Check whether the break triggers</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>bool
ocrpt_break_check_fields(opencreport *o,
                         ocrpt_report *r,
                         ocrpt_break *br);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3191"
>Reset variables for the break</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_break_reset_vars(opencreport *o,
                       ocrpt_report *r,
                       ocrpt_break *br);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN3195"
>Function related functions</A
></H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3197"
>Add a user defined function</A
></H3
><P
>&#13;					Add a user defined function by specifying
					the name, the function pointer that contains
					the implementation, the number of operands
					(0 or greater for fixed number or operands,
					-1 is varying number of operands) and
					the function mathematical properties
					that help optimizing it.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>bool
ocrpt_function_add(opencreport *o,
                   const char *fname,
                   ocrpt_function_call func,
                   int32_t n_ops,
                   bool commutative,
                   bool associative,
                   bool left_associative,
                   bool dont_optimize);</PRE
></TD
></TR
></TABLE
>
				</P
><P
>&#13;					Adding a user defined function with
					a name of a pre-existing function will
					override it.
				</P
><P
>&#13;					OpenCReports functions are called with the
					parameters as declared below.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>#define OCRPT_FUNCTION_PARAMS \
    opencreport *o, \
    ocrpt_report *r OCRPT_UNUSED_PARAM, \
    ocrpt_expr *e</PRE
></TD
></TR
></TABLE
>
				</P
><P
>&#13;					OpenCReports functions may be declared
					with these convenience symbols below.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>#define OCRPT_FUNCTION(name) \
    void name(OCRPT_FUNCTION_PARAMS)

#define OCRPT_STATIC_FUNCTION(name) \
    static void name(OCRPT_FUNCTION_PARAMS)</PRE
></TD
></TR
></TABLE
>
				</P
><P
>&#13;					The above function
					(<TT
CLASS="literal"
>ocrpt_function_add()</TT
>)
					is called with a function pointer which has
					this type:
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>typedef void
(*ocrpt_function_call)(OCRPT_FUNCTION_PARAMS);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3209"
>Find a named function</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>const ocrpt_function *
ocrpt_function_get(opencreport *o,
                   const char *fname);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3213"
>Get number of operands for an expression (function)</A
></H3
><P
>&#13;					In an expression tree, functions
					are represented as subexpressions with
					operands. This call may be used by OpenCReports
					functions to inspect whether the number of
					operands is in the expected range.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>int32_t
ocrpt_expr_get_num_operands(ocrpt_expr *e);
</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3217"
>Get current value of a function operand</A
></H3
><P
>&#13;					This function is used by OpenCReports functions
					internally to compute the result from its
					operands.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_result *
ocrpt_expr_operand_get_result(opencreport *o,
                              ocrpt_expr *e,
                              int32_t opnum);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN3221"
>Report part and report related functions</A
></H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3223"
>Create a report part</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_part *
ocrpt_part_new(opencreport *o);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3227"
>Create a row in a report part</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_part_row *
ocrpt_part_new_row(opencreport *o,
                   ocrpt_part *p);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3231"
>Create a column in report part row</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_part_row_data *
ocrpt_part_row_new_data(opencreport *o,
                        ocrpt_part *p,
                        ocrpt_part_row *pr);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3235"
>Create a new report</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_report *
ocrpt_report_new(opencreport *o);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3239"
>Append the new report to a column</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_part *
ocrpt_part_append_report(opencreport *o,
                         ocrpt_part *p,
                         ocrpt_part_row *pr,
                         ocrpt_part_row_data *pd,
                         ocrpt_report *r);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3243"
>Report part related iterators</A
></H3
><P
>&#13;					Iterators for getting report parts, part rows,
					columns in rows and reports in columns.
					Every iterator function must be called
					the first time with the list pointer set to NULL.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_part *
ocrpt_part_get_next(opencreport *o,
                    ocrpt_list **list);

ocrpt_part_row *
ocrpt_part_row_get_next(ocrpt_part *p,
                        ocrpt_list **list);

ocrpt_part_row_data *
ocrpt_part_row_data_get_next(ocrpt_part_row *pr,
                             ocrpt_list **list);

ocrpt_report *
ocrpt_report_get_next(ocrpt_part_row_data *pd,
                      ocrpt_list **list);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3247"
>Set the main query for a report</A
></H3
><P
>&#13;					Set the main query for a report either by
					the query structure pointer, or by name.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_report_set_main_query(opencreport *o,
                            ocrpt_report *r,
                            const ocrpt_query *query);

void
ocrpt_report_set_main_query_by_name(opencreport *o,
                                    ocrpt_report *r,
                                    const char *query);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3251"
>Get the current row number of the main query</A
></H3
><P
>&#13;					The row number starts from 1.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>long
ocrpt_report_get_query_rownum(opencreport *o,
                              ocrpt_report *r);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3255"
>Resolve all report variables</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_report_resolve_variables(opencreport *o,
                               ocrpt_report *r);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3259"
>Evaluate all report variables</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_report_evaluate_variables(opencreport *o,
                                ocrpt_report *r);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3263"
>Resolve all report breaks</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_report_resolve_breaks(opencreport *o,
                            ocrpt_report *r);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3267"
>Resolve all report expressions</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_report_resolve_expressions(opencreport *o,
                                 ocrpt_report *r);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3271"
>Evaluate all report expressions</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_report_evaluate_expressions(opencreport *o,
                                  ocrpt_report *r);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN3275"
>Callback related functions</A
></H2
><P
>&#13;				Certain stages of the report execution can
				notify the application about the stage
				being executed or finished.
			</P
><P
>&#13;				Every "add a callback" function below return
				<TT
CLASS="literal"
>true</TT
> for success,
				<TT
CLASS="literal"
>false</TT
> for failure.
			</P
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3281"
>Add a "part added" callback</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>typedef void
(*ocrpt_part_cb)(opencreport *,
                 ocrpt_part *,
                 void *data);

bool
ocrpt_add_part_added_cb(opencreport *o,
                        ocrpt_part_cb func,
                        void *data);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3285"
>Add a "report added" callback</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>typedef void
(*ocrpt_report_cb)(opencreport *,
                   ocrpt_report *,
                   void *data);

bool
ocrpt_add_report_added_cb(opencreport *o,
                          ocrpt_report_cb func,
                          void *data);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3289"
>Add a "part iteration" callback</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>bool
ocrpt_add_part_iteration_cb(opencreport *o,
                            ocrpt_part_cb func,
                            void *data);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3293"
>Add an "all precalculations done" callback</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>typedef void
(*ocrpt_cb)(opencreport *,
            void *data);

bool
ocrpt_add_precalculation_done_cb(opencreport *o,
                                 ocrpt_cb func,
                                 void *data);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3297"
>Add a "report started" callback</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>bool
ocrpt_report_add_start_cb(opencreport *o,
                          ocrpt_report *r,
                          ocrpt_report_cb func,
                          void *data);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3301"
>Add a "report done" callback</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>bool
ocrpt_report_add_done_cb(opencreport *o,
                         ocrpt_report *r,
                         ocrpt_report_cb func,
                         void *data);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3305"
>Add a "new row" callback</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>bool
ocrpt_report_add_new_row_cb(opencreport *o,
                            ocrpt_report *r,
                            ocrpt_report_cb func,
                            void *data);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3309"
>Add a "report iteration done" callback</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>bool
ocrpt_report_add_iteration_cb(opencreport *o,
                              ocrpt_report *r,
                              ocrpt_report_cb func,
                              void *data);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3313"
>Add a "report precalculation done" callback</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>bool
ocrpt_report_add_precalculation_done_cb(opencreport *o,
                                        ocrpt_report *r,
                                        ocrpt_report_cb func,
                                        void *data);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3317"
>Add a "break triggers" callback</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>typedef void
(*ocrpt_break_trigger_cb)(opencreport *,
                          ocrpt_report *,
                          ocrpt_break *,
                          void *);

bool
ocrpt_break_add_trigger_cb(opencreport *o,
                           ocrpt_report *r,
                           ocrpt_break *br,
                           ocrpt_break_trigger_cb func,
                           void *data);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN3321"
>Environment related functions</A
></H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3323"
>Indirect function to get an environment variable</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>typedef ocrpt_result *
(*ocrpt_environment_query_func)(const char *);

extern ocrpt_environment_query_func
ocrpt_environment_get;</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3327"
>Set the environment query function</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_environment_set_query_func(ocrpt_environment_query_func func);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3331"
>C API environment query function</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_result *
ocrpt_environment_get_c(const char *env);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN3335"
>File handling related functions</A
></H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3337"
>Return a canonical file path</A
></H3
><P
>&#13;					The returned path contains only single
					directory separators and doesn't contains
					symlinks.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>char *
ocrpt_canonicalize_path(const char *path);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3341"
>Add search path</A
></H3
><P
>&#13;					Add a new directory path to the list of
					search paths. It's useful to find files
					referenced with relative path.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_add_search_path(opencreport *o,
                      const char *path);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3345"
>Find a file</A
></H3
><P
>&#13;					Find a file and return the canonicalized path to it.
					This function takes the search paths into account.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>char *
ocrpt_find_file(opencreport *o,
                const char *filename);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN3349"
>Color related functions</A
></H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3351"
>Find a color by its name</A
></H3
><P
>&#13;					The function fills in the
					<TT
CLASS="literal"
>ocrpt_color</TT
> structure with
					RGB values in Cairo values (0.0 ... 1.0).
				</P
><P
>&#13;					If the color name starts with
					<TT
CLASS="literal"
>#</TT
> or <TT
CLASS="literal"
>0x</TT
> or
					<TT
CLASS="literal"
>0X</TT
> then it must be in HTML
					notation.
				</P
><P
>&#13;					Otherwise, the color name is looked up in the
					color name database in a case insensitive way.
					If found, the passed-in ocrpt_color structure is
					filled with the RGB color value of that name.
				</P
><P
>&#13;					If not found or the passed-in color name is NULL,
					depending on the the expected usage (foreground
					or background color), the <TT
CLASS="literal"
>ocrpt_color</TT
>
					structure is filled with either white or black.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_get_color(opencreport *o,
                const char *cname,
                ocrpt_color *color,
                bool bgcolor);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN3363"
>Paper size related functions</A
></H2
><P
>&#13;				Paper size in OpenCReports is handled via
				<A
HREF="http://packages.qa.debian.org/libp/libpaper.html"
TARGET="_top"
>libpaper</A
>.
			</P
><P
>&#13;				This structure is used in OpenCReports to represent
				paper name and size:
				<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>struct ocrpt_paper {
    const char *name;
    double width;
    double height;
};
typedef struct ocrpt_paper ocrpt_paper;</PRE
></TD
></TR
></TABLE
>
			</P
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3369"
>Get the system default paper</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>const ocrpt_paper *
ocrpt_get_system_paper(void);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3373"
>Get the paper specified by name</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>const ocrpt_paper *
ocrpt_get_paper_by_name(const char *paper);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3377"
>Set the global paper</A
></H3
><P
>&#13;					Set global paper using an
					<TT
CLASS="literal"
>ocrpt_paper</TT
> structure.
					The contents of the structure is copied.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_set_paper(opencreport *o,
                const ocrpt_paper *paper);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3382"
>Set global paper specified by name</A
></H3
><P
>&#13;					Set paper for the report using a paper name.
					If the paper name is unknown, the system default paper is set.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_set_paper_by_name(opencreport *o,
                        const char *paper);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3386"
>Get currently set global paper</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>const ocrpt_paper *
ocrpt_get_paper(opencreport *o);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3390"
>Iterate over paper sizes</A
></H3
><P
>&#13;					Get the next <TT
CLASS="literal"
>ocrpt_paper</TT
> structure
					in the iterator. For the first call, the iterator
					pointer must be NULL. It returns NULL when there are
					no more papers known to the system.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>const ocrpt_paper *
ocrpt_paper_next(opencreport *o,
                 void **iter);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN3395"
>Memory handling related functions</A
></H2
><P
>&#13;				Memory handling is done through an indirection,
				to help with bindings (that may do their own memory
				handling) override the default.
			</P
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3398"
>Indirect function pointers</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>typedef void *
(*ocrpt_mem_malloc_t)(size_t);

typedef void *
(*ocrpt_mem_realloc_t)(void *,
                       size_t);

typedef void *
(*ocrpt_mem_reallocarray_t)(void *,
                            size_t,
                            size_t);

typedef void
(*ocrpt_mem_free_t)(const void *);

typedef char *
(*ocrpt_mem_strdup_t)(const char *);

typedef char *
(*ocrpt_mem_strndup_t)(const char *,
                       size_t);

typedef void
(*ocrpt_mem_free_size_t)(void *,
                         size_t);

extern ocrpt_mem_malloc_t ocrpt_mem_malloc0;
extern ocrpt_mem_realloc_t ocrpt_mem_realloc0;
extern ocrpt_mem_reallocarray_t ocrpt_mem_reallocarray0;
extern ocrpt_mem_free_t ocrpt_mem_free0;
extern ocrpt_mem_strdup_t ocrpt_mem_strdup0;
extern ocrpt_mem_strndup_t ocrpt_mem_strndup0;</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3402"
>Allocate memory</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void *
ocrpt_mem_malloc(size_t sz);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3406"
>Reallocate memory</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void *
ocrpt_mem_realloc(void *ptr,
                  size_t sz);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3410"
>Reallocate array of memory</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void *
ocrpt_mem_reallocarray(void *ptr,
                       size_t nmemb,
                       size_t sz);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3414"
>Free memory</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_mem_free(const void *ptr);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3418"
>Duplicate C string</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void *
ocrpt_mem_strdup(const char *ptr);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3422"
>Duplicate C string up to the specified length</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void *
ocrpt_mem_strndup(const char *ptr,
                  size_t sz);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3426"
>Free a C string</A
></H3
><P
>&#13;					It'a convenience alias for
					<TT
CLASS="literal"
>ocrpt_mem_free()</TT
>.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_strfree(const char *s);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3431"
>Set indirect allocation functions</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_mem_set_alloc_funcs(ocrpt_mem_malloc_t rmalloc,
                          ocrpt_mem_realloc_t rrealloc,
                          ocrpt_mem_reallocarray_t rreallocarray,
                          ocrpt_mem_free_t rfree,
                          ocrpt_mem_strdup_t rstrdup,
                          ocrpt_mem_strndup_t rstrndup);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN3435"
>List related functions</A
></H2
><P
>&#13;				These functions implement a single linked list.
				The list element structure is hidden:
				<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>struct ocrpt_list;
typedef struct ocrpt_list ocrpt_list;</PRE
></TD
></TR
></TABLE
>
			</P
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3439"
>Get the list length</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>size_t
ocrpt_list_length(ocrpt_list *l);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3443"
>Make a list from one element</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_list *
ocrpt_makelist1(const void *data);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3447"
>Make a list from multiple elements</A
></H3
><P
>&#13;					This function can be used with variable
					number of arguments.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_list *
ocrpt_makelist(const void *data1, ...);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3451"
>Get the last element of a list</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_list *
ocrpt_list_last(const ocrpt_list *l);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3455"
>Get the nth element of a list</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_list *
ocrpt_list_nth(const ocrpt_list *l, uint32_t n);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3459"
>Append a new element to a list</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_list *
ocrpt_list_append(ocrpt_list *l,
                  const void *data);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3463"
>Append to list using the last element</A
></H3
><P
>&#13;					This function make appending to the list work
					<I
CLASS="emphasis"
>O(1)</I
> instead of
					<I
CLASS="emphasis"
>O(n)</I
>.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_list *
ocrpt_list_end_append(ocrpt_list *l,
                      ocrpt_list **e,
                      const void *data);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3469"
>Prepend a new element to a list</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_list *
ocrpt_list_prepend(ocrpt_list *l,
                   const void *data);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3473"
>Remove a data element from a list</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_list *
ocrpt_list_remove(ocrpt_list *l,
                  const void *data);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3477"
>Get the data element from a list</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void *
ocrpt_list_get_data(ocrpt_list *l);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3481"
>Free a list</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_list_free(ocrpt_list *l);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3485"
>Free a list and its data elements</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_list_free_deep(ocrpt_list *l,
                     ocrpt_mem_free_t freefunc);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN3489"
>String related functions</A
></H2
><P
>&#13;				For memory safety and higher performance, a wrapper
				structure is used over C functions.
				<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>struct ocrpt_string {
    char *str;
    size_t allocated_len;
    size_t len;
};
typedef struct ocrpt_string ocrpt_string;</PRE
></TD
></TR
></TABLE
>
			</P
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3493"
>Create a new string</A
></H3
><P
>&#13;					Create a new string from a C string.
					The ownership of the input string may be
					taken over, or the original string's contents
					are copied.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_string *
ocrpt_mem_string_new(const char *str,
                     bool copy);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3497"
>Create a new string with specified allocated length</A
></H3
><P
>&#13;					Create a new string with specified allocated length
					so future growth can be done without reallocation.
					The input string is always copied.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_string *
ocrpt_mem_string_new_with_len(const char *str,
                              size_t len);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3501"
>Create a string from a formatted string with maximum length</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_string *
ocrpt_mem_string_new_vnprintf(size_t len,
                              const char *format,
                              va_list va);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3505"
>Create a string from a formatted string</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_string *
ocrpt_mem_string_new_printf(const char *format, ...);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3509"
>Resize a string</A
></H3
><P
>&#13;					Resize the string to the specified allocated
					length.
					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>ocrpt_string *
ocrpt_mem_string_resize(ocrpt_string *string,
                        size_t len);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3513"
>Free a string</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>char *
ocrpt_mem_string_free(ocrpt_string *string,
                      bool free_str);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3517"
>Append a C string of the specified length to a string</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_mem_string_append_len(ocrpt_string *string,
                            const char *str,
                            const size_t len);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3521"
>Append a binary string of the specified length to a string</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_mem_string_append_len_binary(ocrpt_string *string,
                                   const char *str,
                                   const size_t len);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3525"
>Append a C string of unspecified length to a string</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_mem_string_append(ocrpt_string *string,
                        const char *str);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3529"
>Append a byte to a string</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_mem_string_append_c(ocrpt_string *string,
                          const char c);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN3533"
>Append a formatted string to a string</A
></H3
><P
>&#13;					<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>void
ocrpt_mem_string_append_printf(ocrpt_string *string,
                               const char *format, ...);</PRE
></TD
></TR
></TABLE
>
				</P
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x2693.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c3537.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>High level C API</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c2687.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>GNU Free Documentation License</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>